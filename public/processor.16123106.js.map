{"mappings":"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","sources":["<anon>","src/pages/composition/scripts/latencyadenot/processor.js"],"sourcesContent":["var $d708469c47a30b2d$exports = {};\nfunction $d708469c47a30b2d$var$mod(n, m) {\n    return (n % m + m) % m;\n}\nclass $d708469c47a30b2d$var$MeasureProcessor extends AudioWorkletProcessor {\n    constructor(...args){\n        super(args);\n        this.interval = 1 * globalThis.sampleRate;\n        this.remaining = this.interval;\n        this.start = 0;\n        this.tapped = false;\n        this.threshold = 0.2;\n        // Noise burst synthesis parameter\n        this.sq_frames = 64;\n        this.sq_remaining = 64;\n        this.sq_period = 16;\n        this.sq_amp = 0.8;\n        // A ring buffer that always keep the last 1000ms of audio to be able to find\n        // the beginning of the noise burst a peak has been found.\n        this.ringbuf = new Float32Array(globalThis.sampleRate);\n        this.write_idx = 0;\n    //var self = this;\n    // this.port.onmessage = function (e) {\n    //     self.threshold = e.data.threshold;\n    // }\n    }\n    // record a single sample in the ring buffer\n    record(sample) {\n        this.ringbuf[this.write_idx] = sample;\n        this.write_idx = $d708469c47a30b2d$var$mod(this.write_idx + 1, this.ringbuf.length);\n    }\n    // get a sample from the ring buffer. idx is an offset in the past, 0 is the\n    // sample most recently written to the ring buffer\n    get_past_sample(idx) {\n        var not_wrapped = this.write_idx - 1 - idx;\n        var i = $d708469c47a30b2d$var$mod(this.write_idx - 1 - idx, this.ringbuf.length);\n        return this.ringbuf[i];\n    }\n    process(inputs, outputs) {\n        //console.log(inputs[0][0].length); // this shows the bufferSize\n        var input = inputs[0];\n        if (!input.length) return true;\n        var mono_input = input[0];\n        var mono_output = outputs[0][0];\n        for(var i = 0; i < mono_input.length; i++){\n            // This matches on a positive peak\n            if (mono_input[i] > this.threshold && this.tapped) {\n                // try to find the beginning of the pattern, because what's been found\n                // is probably a peak, which is in the middle of the burst. Scan\n                // back the last 10ms or so.\n                var idx_first_zero_crossing = -1;\n                var scan_back_idx = 0;\n                while(scan_back_idx++ != this.ringbuf.length)if (this.get_past_sample(scan_back_idx) < 0) {\n                    idx_first_zero_crossing = scan_back_idx;\n                    break;\n                }\n                // we expect zero crossing around each 8 frames. Stop when that's not\n                // the case anymore. This is not very good, this should be scanning\n                // window + correlation maximisation.\n                var sign = true;\n                var current_period = 0;\n                while(scan_back_idx++ != this.ringbuf.length){\n                    var computed_period = (scan_back_idx - idx_first_zero_crossing) / this.sq_period;\n                    if (sign != Math.sign(this.get_past_sample(scan_back_idx))) {\n                        // zero crossing, fuzz match\n                        if (Math.abs(current_period - computed_period) > 2) break;\n                    }\n                }\n                // send back frames from the past to the main thread to display in debug\n                // mode\n                var frames_delay = globalThis.currentFrame + i - scan_back_idx - this.start;\n                if (frames_delay > 0) {\n                    var debugarray = new Float32Array(frames_delay * 2);\n                    var rdIdx = 0;\n                    for(var j = 0; j < debugarray.length; j++)debugarray[debugarray.length - j] = this.get_past_sample(j);\n                    var latency_s = frames_delay / globalThis.sampleRate;\n                    this.port.postMessage({\n                        latency: latency_s,\n                        array: debugarray,\n                        offset: scan_back_idx,\n                        delay_frames: frames_delay\n                    });\n                }\n                this.tapped = false;\n            }\n            if (this.remaining == 0) {\n                if (this.sq_remaining == this.sq_frames) {\n                    this.tapped = true;\n                    this.start = globalThis.currentFrame + i;\n                    mono_input[i] = -1;\n                }\n                mono_output[i] = this.sq_remaining % this.sq_period > this.sq_period / 2 ? this.sq_amp : -this.sq_amp;\n                this.sq_remaining--;\n                if (this.sq_remaining == 0) {\n                    this.sq_remaining = this.sq_frames;\n                    this.remaining = this.interval;\n                }\n            } else this.remaining--;\n            this.record(mono_input[i] + mono_output[i]);\n        // Following line commented to avoid Larssen effect / feedback\n        //mono_output[i] += mono_input[i];\n        }\n        return true;\n    }\n}\nregisterProcessor(\"measure-processor\", $d708469c47a30b2d$var$MeasureProcessor);\n\n\n//# sourceMappingURL=processor.16123106.js.map\n","function mod(n, m) {\n    return ((n % m) + m) % m;\n}\nclass MeasureProcessor extends AudioWorkletProcessor {\n    constructor(...args) {\n        super(args);\n        this.interval = 1 * globalThis.sampleRate;\n        this.remaining = this.interval;\n        this.start = 0;\n        this.tapped = false;\n\n        this.threshold = 0.2;\n\n        // Noise burst synthesis parameter\n        this.sq_frames = 64;\n        this.sq_remaining = 64;\n        this.sq_period = 16;\n        this.sq_amp = 0.8;\n        // A ring buffer that always keep the last 1000ms of audio to be able to find\n        // the beginning of the noise burst a peak has been found.\n        this.ringbuf = new Float32Array(globalThis.sampleRate);\n        this.write_idx = 0;\n        //var self = this;\n        // this.port.onmessage = function (e) {\n        //     self.threshold = e.data.threshold;\n        // }\n    }\n    // record a single sample in the ring buffer\n    record(sample) {\n        this.ringbuf[this.write_idx] = sample;\n        this.write_idx = mod(this.write_idx + 1, this.ringbuf.length);\n    }\n    // get a sample from the ring buffer. idx is an offset in the past, 0 is the\n    // sample most recently written to the ring buffer\n    get_past_sample(idx) {\n        var not_wrapped = this.write_idx - 1 - idx;\n        var i = mod(this.write_idx - 1 - idx, this.ringbuf.length);\n        return this.ringbuf[i];\n    }\n    process(inputs, outputs) {\n        //console.log(inputs[0][0].length); // this shows the bufferSize\n        var input = inputs[0];\n        if (!input.length) {\n            return true;\n        }\n        var mono_input = input[0];\n        var mono_output = outputs[0][0];\n        for (var i = 0; i < mono_input.length; i++) {\n            // This matches on a positive peak\n            if (mono_input[i] > this.threshold && this.tapped) {\n                // try to find the beginning of the pattern, because what's been found\n                // is probably a peak, which is in the middle of the burst. Scan\n                // back the last 10ms or so.\n                var idx_first_zero_crossing = -1;\n                var scan_back_idx = 0;\n                while (scan_back_idx++ != this.ringbuf.length) {\n                    if (this.get_past_sample(scan_back_idx) < 0) {\n                        idx_first_zero_crossing = scan_back_idx;\n                        break;\n                    }\n                }\n                // we expect zero crossing around each 8 frames. Stop when that's not\n                // the case anymore. This is not very good, this should be scanning\n                // window + correlation maximisation.\n                var sign = true;\n                var current_period = 0;\n                while (scan_back_idx++ != this.ringbuf.length) {\n                    var computed_period = (scan_back_idx - idx_first_zero_crossing) / this.sq_period;\n                    if (sign != Math.sign(this.get_past_sample(scan_back_idx))) {\n                        // zero crossing, fuzz match\n                        if (Math.abs(current_period - computed_period) > 2) {\n                            // too far away from the generated burst, break and consider this\n                            // the beginning of the burst.\n                            break;\n                        }\n                    }\n                }\n                // send back frames from the past to the main thread to display in debug\n                // mode\n                var frames_delay = (globalThis.currentFrame + i - scan_back_idx) - this.start;\n                if (frames_delay > 0) {\n                    var debugarray = new Float32Array(frames_delay * 2);\n                    var rdIdx = 0;\n                    for (var j = 0; j < debugarray.length; j++) {\n                        debugarray[debugarray.length - j] = this.get_past_sample(j);\n                    }\n                    var latency_s = frames_delay / globalThis.sampleRate;\n                    this.port.postMessage({\n                        latency: latency_s,\n                        array: debugarray,\n                        offset: scan_back_idx,\n                        delay_frames: frames_delay\n                    });\n                }\n                this.tapped = false;\n            }\n            if (this.remaining == 0) {\n                if (this.sq_remaining == this.sq_frames) {\n                    this.tapped = true;\n                    this.start = globalThis.currentFrame + i;\n                    mono_input[i] = -1.0;\n                }\n                mono_output[i] = (this.sq_remaining % this.sq_period) >\n                    this.sq_period / 2 ? this.sq_amp : -this.sq_amp;\n                this.sq_remaining--;\n                if (this.sq_remaining == 0) {\n                    this.sq_remaining = this.sq_frames;\n                    this.remaining = this.interval;\n                }\n            } else {\n                this.remaining--;\n            }\n            this.record(mono_input[i] + mono_output[i]);\n            // Following line commented to avoid Larssen effect / feedback\n            //mono_output[i] += mono_input[i];\n        }\n        return true;\n    }\n}\nregisterProcessor('measure-processor', MeasureProcessor);"],"names":["$d708469c47a30b2d$var$MeasureProcessor","AudioWorkletProcessor","constructor","args","interval","globalThis","sampleRate","remaining","start","tapped","threshold","sq_frames","sq_remaining","sq_period","sq_amp","ringbuf","Float32Array","write_idx","record","sample","m","n","length","get_past_sample","idx","i","process","inputs","outputs","input","mono_input","mono_output","idx_first_zero_crossing","scan_back_idx","computed_period","sign","Math","abs","current_period","frames_delay","currentFrame","debugarray","j","latency_s","port","postMessage","latency","array","offset","delay_frames","registerProcessor"],"version":3,"file":"processor.16123106.js.map"}