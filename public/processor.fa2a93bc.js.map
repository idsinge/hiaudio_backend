{"mappings":"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","sources":["src/pages/composition/scripts/latencyadenot/processor.js"],"sourcesContent":["function mod(n, m) {\n    return ((n % m) + m) % m;\n}\nclass MeasureProcessor extends AudioWorkletProcessor {\n    constructor(...args) {\n        super(args);\n        this.interval = 1 * globalThis.sampleRate;\n        this.remaining = this.interval;\n        this.start = 0;\n        this.tapped = false;\n\n        this.threshold = 0.2;\n\n        // Noise burst synthesis parameter\n        this.sq_frames = 64;\n        this.sq_remaining = 64;\n        this.sq_period = 16;\n        this.sq_amp = 0.8;\n        // A ring buffer that always keep the last 1000ms of audio to be able to find\n        // the beginning of the noise burst a peak has been found.\n        this.ringbuf = new Float32Array(globalThis.sampleRate);\n        this.write_idx = 0;\n        //var self = this;\n        // this.port.onmessage = function (e) {\n        //     self.threshold = e.data.threshold;\n        // }\n    }\n    // record a single sample in the ring buffer\n    record(sample) {\n        this.ringbuf[this.write_idx] = sample;\n        this.write_idx = mod(this.write_idx + 1, this.ringbuf.length);\n    }\n    // get a sample from the ring buffer. idx is an offset in the past, 0 is the\n    // sample most recently written to the ring buffer\n    get_past_sample(idx) {\n        var not_wrapped = this.write_idx - 1 - idx;\n        var i = mod(this.write_idx - 1 - idx, this.ringbuf.length);\n        return this.ringbuf[i];\n    }\n    process(inputs, outputs) {\n        //console.log(inputs[0][0].length); // this shows the bufferSize\n        var input = inputs[0];\n        if (!input.length) {\n            return true;\n        }\n        var mono_input = input[0];\n        var mono_output = outputs[0][0];\n        for (var i = 0; i < mono_input.length; i++) {\n            // This matches on a positive peak\n            if (mono_input[i] > this.threshold && this.tapped) {\n                // try to find the beginning of the pattern, because what's been found\n                // is probably a peak, which is in the middle of the burst. Scan\n                // back the last 10ms or so.\n                var idx_first_zero_crossing = -1;\n                var scan_back_idx = 0;\n                while (scan_back_idx++ != this.ringbuf.length) {\n                    if (this.get_past_sample(scan_back_idx) < 0) {\n                        idx_first_zero_crossing = scan_back_idx;\n                        break;\n                    }\n                }\n                // we expect zero crossing around each 8 frames. Stop when that's not\n                // the case anymore. This is not very good, this should be scanning\n                // window + correlation maximisation.\n                var sign = true;\n                var current_period = 0;\n                while (scan_back_idx++ != this.ringbuf.length) {\n                    var computed_period = (scan_back_idx - idx_first_zero_crossing) / this.sq_period;\n                    if (sign != Math.sign(this.get_past_sample(scan_back_idx))) {\n                        // zero crossing, fuzz match\n                        if (Math.abs(current_period - computed_period) > 2) {\n                            // too far away from the generated burst, break and consider this\n                            // the beginning of the burst.\n                            break;\n                        }\n                    }\n                }\n                // send back frames from the past to the main thread to display in debug\n                // mode\n                var frames_delay = (globalThis.currentFrame + i - scan_back_idx) - this.start;\n                if (frames_delay > 0) {\n                    var debugarray = new Float32Array(frames_delay * 2);\n                    var rdIdx = 0;\n                    for (var j = 0; j < debugarray.length; j++) {\n                        debugarray[debugarray.length - j] = this.get_past_sample(j);\n                    }\n                    var latency_s = frames_delay / globalThis.sampleRate;\n                    this.port.postMessage({\n                        latency: latency_s,\n                        array: debugarray,\n                        offset: scan_back_idx,\n                        delay_frames: frames_delay\n                    });\n                }\n                this.tapped = false;\n            }\n            if (this.remaining == 0) {\n                if (this.sq_remaining == this.sq_frames) {\n                    this.tapped = true;\n                    this.start = globalThis.currentFrame + i;\n                    mono_input[i] = -1.0;\n                }\n                mono_output[i] = (this.sq_remaining % this.sq_period) >\n                    this.sq_period / 2 ? this.sq_amp : -this.sq_amp;\n                this.sq_remaining--;\n                if (this.sq_remaining == 0) {\n                    this.sq_remaining = this.sq_frames;\n                    this.remaining = this.interval;\n                }\n            } else {\n                this.remaining--;\n            }\n            this.record(mono_input[i] + mono_output[i]);\n            // Following line commented to avoid Larssen effect / feedback\n            //mono_output[i] += mono_input[i];\n        }\n        return true;\n    }\n}\nregisterProcessor('measure-processor', MeasureProcessor);"],"names":[],"version":3,"file":"processor.fa2a93bc.js.map","sourceRoot":"/__parcel_source_root/"}